
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Understanding the Crystal Ball Function | The Colour of My Thoughts</title>
    <meta name="description"
        content="
Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.

Introduction
The Crystal Ball Problem is a metaphor for predicting future elements or trends in an array based solely on its current sequence. Imagine you have an array of numbers representing data points over time—such as stock prices or weather data—and your task is to forecast the upcoming values. The “crystal ball” is our metaphor for the ability to foresee these future values.">
    <link rel="canonical" href="https://johnburns.io/post/understanding-the-crystal-ball-function/" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    
    <link rel="stylesheet" href="https://johnburns.io/scss/style.min.aa7209164f013c6883aa54384ea45a46e582eacf9a17e9565badebd557dd1059.css">

    <meta property="og:url" content="https://johnburns.io/post/understanding-the-crystal-ball-function/">
  <meta property="og:site_name" content="The Colour of My Thoughts">
  <meta property="og:title" content="Understanding the Crystal Ball Function">
  <meta property="og:description" content="Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.
Introduction The Crystal Ball Problem is a metaphor for predicting future elements or trends in an array based solely on its current sequence. Imagine you have an array of numbers representing data points over time—such as stock prices or weather data—and your task is to forecast the upcoming values. The “crystal ball” is our metaphor for the ability to foresee these future values.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-04-05T21:13:00-04:00">
    <meta property="article:modified_time" content="2024-04-05T21:14:42-04:00">

    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Understanding the Crystal Ball Function">
  <meta name="twitter:description" content="Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.
Introduction The Crystal Ball Problem is a metaphor for predicting future elements or trends in an array based solely on its current sequence. Imagine you have an array of numbers representing data points over time—such as stock prices or weather data—and your task is to forecast the upcoming values. The “crystal ball” is our metaphor for the ability to foresee these future values.">

    
    

</head><body><nav class="navbar is-light" role="navigation">
    <div class="container">
        <div class="navbar-brand">
            <a href="/" title="home" class="navbar-item">
                <span class="logo">
                    <h1>The Colour of My Thoughts</h1>
                </span>
            </a>

            
            <a id="theme-toggle" class="theme-toggle" href="#">
                <img src="https://johnburns.io/svg/sun.svg" alt="sun icon" class="theme-icon" />
            </a>

            <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>

        <div class="navbar-menu">
            <div class="navbar-start">
                
                <a href="/about/" class="navbar-item">About</a>
                
                <a href="/resume.pdf" class="navbar-item">Resume</a>
                
                <a href="/contact/" class="navbar-item">Contact</a>
                
            </div>

        </div>
        <div class="search">
            <div id="fastSearch">
                <input id="searchInput" tabindex="0" placeholder="Search..">
                <ul id="searchResults">

                </ul>
            </div>
            <a id="search-btn" style="display: inline-block;" href="# ">
                <div class="icon-search"><svg class="search-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></div>
            </a>
        </div>

        <script src="/js/fuse.min.js"></script> 
        <script src="/js/fastsearch.js"></script>

    </div>
</nav>
<script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: "\\(", right: "\\)", display: false},
          {left: "$", right: "$", display: false},
          {left: "\\[", right: "\\]", display: true},
          {left: "$$", right: "$$", display: true}
        ]
      });
    });
  </script>
<script>
    
    document.addEventListener('DOMContentLoaded', function() {
        var burger = document.querySelector('.navbar-burger');
        burger.addEventListener('click', function() {
            burger.classList.toggle('is-active');
            document.querySelector('.navbar-menu').classList.toggle('is-active');
        });
    });

    
    function setTheme(theme) {
        let body = document.body;
        let themeIcon = document.querySelector(".theme-icon");
        if (theme === "dark") {
            body.classList.add("dark-mode");
            themeIcon.src = "https:\/\/johnburns.io\/svg/moon.svg";
            themeIcon.alt = "moon icon";
        } else {
            body.classList.remove("dark-mode");
            themeIcon.src = "https:\/\/johnburns.io\/svg/sun.svg";
            themeIcon.alt = "sun icon";
        }
        
        localStorage.setItem("theme", theme);
    }

    
    let theme = localStorage.getItem("theme") || "light";
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (isDarkMode) {
        
        setTheme('dark');

    } else {
        
        setTheme('light');
    }
    setTheme(theme);

    
    document.getElementById("theme-toggle").addEventListener("click", function() {
        if (theme === "light") {
            theme = "dark";
        } else {
            theme = "light";
        }
        setTheme(theme);
    });



</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LQNL2E5MEL"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LQNL2E5MEL');
</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>
  
  document.addEventListener('DOMContentLoaded', function() {
    mermaid.initialize({ startOnLoad: true });
  });
</script>
</header><main>
<div class="single-container">
    <div class="archive">
        <h1 class="title is-1">Understanding the Crystal Ball Function</h1>
        <div class="title subtitle heading is-6">
            <div class="author-info columns is-vcentered">
                <div class="column">
                    <div class="columns is-vcentered is-mobile">
                        
                        <div class="column">
                            <p>John Burns</p>
                            <p><time>April 5, 2024</time>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="small-categories-container">
                    
                </div>
            </div>
        </div>
        <div class="content article-content">
            <div class="toc-container">
                
    <div class="post-toc">
        
            <aside>
                <button id="tocButton" ><h4 id="contents" style="margin-left: 1vw;color:rgb(96, 134, 180);margin-bottom: 0;">CONTENTS</h4></button>
                <div id="hide"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#why-square-root-of-n">Why Square Root of <em>n</em>?</a>
      <ul>
        <li><a href="#optimization-balance">Optimization Balance</a></li>
        <li><a href="#trade-off-between-jump-and-search">Trade-off Between Jump and Search</a></li>
        <li><a href="#theoretical-justification">Theoretical Justification</a></li>
      </ul>
    </li>
    <li><a href="#alternative-roots">Alternative Roots</a></li>
    <li><a href="#mathematical-justification">Mathematical Justification</a>
      <ul>
        <li><a href="#setting-up-the-problem">Setting Up the Problem</a></li>
        <li><a href="#total-search-steps">Total Search Steps</a></li>
        <li><a href="#finding-the-optimal-m">Finding the Optimal <em>m</em></a></li>
        <li><a href="#example-with-n--100">Example with <em>n = 100</em></a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav></div>
            </aside>
        
    </div><script>
    
        let button = document.getElementById('tocButton');
        let hide = document.getElementById("hide");
        let contents=document.getElementById("contents");
        button.addEventListener("click", function() {
        if (hide.style.display!='block') {
            hide.style.display='block'
        } else {
            hide.style.display='none'
            contents.style.color='rgb(96, 134, 180)'
        }
        });
    




</script>
            </div>
            <!--start-summary-->
<p>Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.</p>
<!--nomore-->
<h2 id="introduction">Introduction</h2>
<p>The <strong>Crystal Ball Problem</strong> is a metaphor for predicting future elements or trends in an array based solely on its current sequence. Imagine you have an array of numbers representing data points over time—such as stock prices or weather data—and your task is to forecast the upcoming values. The “crystal ball” is our metaphor for the ability to foresee these future values.</p>
<p>In computational terms, this problem relates to creating algorithms that analyze and extrapolate patterns from arrays. Given an array $ A $ of length $ n $ with elements</p>
<p>$$
A[1], A[2], \dots, A[n],
$$</p>
<p>the challenge is to predict</p>
<p>$$
A[n+1], A[n+2], \dots
$$</p>
<p>based on the underlying patterns or rules governing the progression of the array’s elements.</p>
<hr>
<h2 id="why-square-root-of-n">Why Square Root of <em>n</em>?</h2>
<h3 id="optimization-balance">Optimization Balance</h3>
<p>When using Jump Search in a sorted array, the search is divided into two phases:</p>
<ol>
<li><strong>Jump Phase:</strong> Jump in fixed blocks until you find a block that may contain the target.</li>
<li><strong>Linear Search Phase:</strong> Perform a linear search within that block.</li>
</ol>
<p>The total number of steps can be roughly modeled as the sum of the number of jumps and the number of steps in the linear search. By choosing a block size $ m $ proportional to $\sqrt{n}$, we optimize this sum.</p>
<h3 id="trade-off-between-jump-and-search">Trade-off Between Jump and Search</h3>
<ul>
<li><strong>Large Jump Size (e.g., using $ n^{1/3} $)</strong>: Fewer jumps but a longer linear search.</li>
<li><strong>Small Jump Size (less than $\sqrt{n}$)</strong>: More jumps but a shorter linear search.</li>
</ul>
<p>The square root of $ n $ balances the two phases so that neither dominates the total search time.</p>
<h3 id="theoretical-justification">Theoretical Justification</h3>
<p>Mathematically, when you differentiate the total search steps with respect to $ m $ and set the derivative to zero, you find that the optimal $ m $ is proportional to $\sqrt{n}$. This balance minimizes the worst-case scenario search time.</p>
<hr>
<h2 id="alternative-roots">Alternative Roots</h2>
<p>Using an alternative root such as the cube root of $ n $ would disturb this balance. It might reduce the number of jumps but at the expense of increasing the number of elements checked in the linear search phase—or vice versa. The square root remains the most effective choice in general because it equally balances both components of the search.</p>
<hr>
<h2 id="mathematical-justification">Mathematical Justification</h2>
<h3 id="setting-up-the-problem">Setting Up the Problem</h3>
<p>In <strong>Jump Search</strong>, you jump through an ordered list in increments of $ m $ until you overshoot the target value. Then, you perform a linear search in the identified block. The key is to minimize the total number of steps.</p>
<ul>
<li><strong>Maximum number of jumps:</strong> $ \frac{n}{m} $</li>
<li><strong>Maximum number of linear search steps:</strong> $ m - 1 $ (or simply $ m $ for simplicity)</li>
</ul>
<p>Thus, the total number of steps $ T(m) $ can be approximated by:</p>
<p>$$
T(m) = \frac{n}{m} + m.
$$</p>
<h3 id="total-search-steps">Total Search Steps</h3>
<p>The function</p>
<p>$$
T(m) = \frac{n}{m} + m
$$</p>
<p>captures the trade-off: decreasing $ m $ increases the jump count, while increasing $ m $ lengthens the linear search.</p>
<h3 id="finding-the-optimal-m">Finding the Optimal <em>m</em></h3>
<p>To find the optimal block size $ m $, differentiate $ T(m) $ with respect to $ m $:</p>
<p>$$
\frac{d}{dm}T(m) = -\frac{n}{m^2} + 1.
$$</p>
<p>Setting the derivative to zero gives:</p>
<p>$$
-\frac{n}{m^2} + 1 = 0 \quad \Longrightarrow \quad m^2 = n,
$$</p>
<p>which implies:</p>
<p>$$
m = \sqrt{n}.
$$</p>
<h3 id="example-with-n--100">Example with <em>n = 100</em></h3>
<p>For an array of 100 elements:</p>
<p>$$
m = \sqrt{100} = 10.
$$</p>
<p>This means:</p>
<ul>
<li><strong>Jump Size:</strong> Jump every 10 elements (i.e., indices 0, 10, 20, …, 90).</li>
<li><strong>Linear Search:</strong> After jumping, perform a linear search in a block of up to 10 elements.</li>
</ul>
<h4 id="illustration-with-python-code">Illustration with Python Code</h4>
<p>Below is a Python code snippet that plots the total search steps $ T(m) $ against different block sizes $ m $ for a given $ n $. The plot highlights the optimal block size at $ m = \sqrt{n} $.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set array length</span>
</span></span><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate a range of possible m values</span>
</span></span><span style="display:flex;"><span>m_values <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">1</span>, n, <span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>T <span style="color:#f92672">=</span> n <span style="color:#f92672">/</span> m_values <span style="color:#f92672">+</span> m_values
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calculate optimal m</span>
</span></span><span style="display:flex;"><span>optimal_m <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sqrt(n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Plot the total search steps vs. block size</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(m_values, T, label<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;$T(m)=\frac</span><span style="color:#e6db74">{n}{m}</span><span style="color:#e6db74">+m$&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;Block Size (m)&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;Total Search Steps T(m)&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Total Search Steps vs. Block Size for n=</span><span style="color:#e6db74">{</span>n<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(x<span style="color:#f92672">=</span>optimal_m, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Optimal m = sqrt(n) ≈ </span><span style="color:#e6db74">{</span>optimal_m<span style="color:#e6db74">:</span><span style="color:#e6db74">.2f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="/crystal_1_0.png" alt="png"></p>
<p><em>Explanation:</em><br>
The code above computes and plots $ T(m) $ for $ n = 1000 $ over a range of $ m $ values. The vertical dashed line indicates the optimal block size $ m = \sqrt{1000} $.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<p>The use of $ m = \sqrt{n} $ in the Jump Search algorithm optimally balances the number of jumps and the linear search steps, leading to a worst-case time complexity of $ O(\sqrt{n}) $. This balance is crucial for efficient search in unsorted or partially ordered arrays, and the mathematical justification confirms the effectiveness of this approach.</p>

        </div>
    </div>
    <a href="#" id="scrollToTopButton">
        <svg t="1686753152588" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
            p-id="3988" width="48" height="48">
            <path
                d="M518.5 360.3c-3.2-4.4-9.7-4.4-12.9 0l-178 246c-3.8 5.3 0 12.7 6.5 12.7H381c10.2 0 19.9-4.9 25.9-13.2L512 460.4l105.2 145.4c6 8.3 15.6 13.2 25.9 13.2H690c6.5 0 10.3-7.4 6.5-12.7l-178-246z"
                p-id="3989" fill="#363636"></path>
            <path
                d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                p-id="3990" fill="#363636"></path>
        </svg>
    </a><hr style="border-top: 1px solid #EEEEEE;">
<div id="comment"></div>
<script>
    const getStoredTheme = () => localStorage.getItem("theme") === "dark" ? "dark" : "light";

    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "bufo333\/johnburns.io_public",
            "data-repo-id": "R_kgDOHYBJIg",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOHYBJIs4Cokmt",
            "data-mapping": "og:title",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "en",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
            ([key, value]) => giscusScript.setAttribute(key, value));
        document.getElementById("comment").appendChild(giscusScript);

        
        const themeToggle = document.querySelector(".theme-toggle");
        if (themeToggle) {
            themeToggle.addEventListener("click", setGiscusTheme);
        }
    });

</script>


<div class="pp-container">
        <section class="pre-and-post">
            <div class="has-text-left">
                
                <p>Previous post</p>
                <a href="https://johnburns.io/post/store-dotfile-with-git/">Store dotfile with git</a>
                
            </div>
            <div class="has-text-right">
                
                <p>Next post</p>
                <a href="https://johnburns.io/post/orbital-mechanics/">Mathematics &amp; Physics for understanding Orbital Mechanics</a>
                
            </div>
        </section>
    </div>

</div>

        </main><footer class="footer">
    <div class="content has-text-centered">
    <span>&copy; 2025 <a href="https://johnburns.io/">The Colour of My Thoughts</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" target="_blank">Hugo</a> &
    </span>
    </div>
  </footer></body>
</html>

