
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>Understanding the Crystal Ball Function | The Colour of My Thoughts</title>
    <meta name="description"
        content="Date: &lt;2024-04-07 Sun&gt;
Subject: Understanding the Crystal Ball Function
Version: 1.0

Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.

Introduction to the Crystal Ball Problem with Arrays
The Crystal Ball Problem in the context of arrays is a metaphorical representation of the challenge of predicting future elements or trends based on a current sequence of data. Imagine you have an array of numbers representing data points over time. The task is to predict the next set of values the array will hold using only the information currently available.">
    <link rel="canonical" href="https://johnburns.io/post/understanding-the-crystal-ball-function/" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.4/css/bulma.min.css">
    
    <link rel="stylesheet" href="https://johnburns.io/scss/style.min.aa7209164f013c6883aa54384ea45a46e582eacf9a17e9565badebd557dd1059.css">

    <meta property="og:url" content="https://johnburns.io/post/understanding-the-crystal-ball-function/">
  <meta property="og:site_name" content="The Colour of My Thoughts">
  <meta property="og:title" content="Understanding the Crystal Ball Function">
  <meta property="og:description" content="Date: &lt;2024-04-07 Sun&gt;
Subject: Understanding the Crystal Ball Function
Version: 1.0
Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.
Introduction to the Crystal Ball Problem with Arrays The Crystal Ball Problem in the context of arrays is a metaphorical representation of the challenge of predicting future elements or trends based on a current sequence of data. Imagine you have an array of numbers representing data points over time. The task is to predict the next set of values the array will hold using only the information currently available.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-04-05T21:13:00-04:00">
    <meta property="article:modified_time" content="2024-04-05T21:14:42-04:00">

    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Understanding the Crystal Ball Function">
  <meta name="twitter:description" content="Date: &lt;2024-04-07 Sun&gt;
Subject: Understanding the Crystal Ball Function
Version: 1.0
Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.
Introduction to the Crystal Ball Problem with Arrays The Crystal Ball Problem in the context of arrays is a metaphorical representation of the challenge of predicting future elements or trends based on a current sequence of data. Imagine you have an array of numbers representing data points over time. The task is to predict the next set of values the array will hold using only the information currently available.">

    
    

</head><body><nav class="navbar is-light" role="navigation">
    <div class="container">
        <div class="navbar-brand">
            <a href="/" title="home" class="navbar-item">
                <span class="logo">
                    <h1>The Colour of My Thoughts</h1>
                </span>
            </a>

            
            <a id="theme-toggle" class="theme-toggle" href="#">
                <img src="https://johnburns.io/svg/sun.svg" alt="sun icon" class="theme-icon" />
            </a>

            <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
                <span aria-hidden="true"></span>
            </a>
        </div>

        <div class="navbar-menu">
            <div class="navbar-start">
                
                <a href="/about/" class="navbar-item">About</a>
                
                <a href="/resume.pdf" class="navbar-item">Resume</a>
                
                <a href="/contact/" class="navbar-item">Contact</a>
                
            </div>

        </div>
        <div class="search">
            <div id="fastSearch">
                <input id="searchInput" tabindex="0" placeholder="Search..">
                <ul id="searchResults">

                </ul>
            </div>
            <a id="search-btn" style="display: inline-block;" href="# ">
                <div class="icon-search"><svg class="search-svg" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></div>
            </a>
        </div>

        <script src="/js/fuse.min.js"></script> 
        <script src="/js/fastsearch.js"></script>

    </div>
</nav>

<script>
    
    document.addEventListener('DOMContentLoaded', function() {
        var burger = document.querySelector('.navbar-burger');
        burger.addEventListener('click', function() {
            burger.classList.toggle('is-active');
            document.querySelector('.navbar-menu').classList.toggle('is-active');
        });
    });

    
    function setTheme(theme) {
        let body = document.body;
        let themeIcon = document.querySelector(".theme-icon");
        if (theme === "dark") {
            body.classList.add("dark-mode");
            themeIcon.src = "https:\/\/johnburns.io\/svg/moon.svg";
            themeIcon.alt = "moon icon";
        } else {
            body.classList.remove("dark-mode");
            themeIcon.src = "https:\/\/johnburns.io\/svg/sun.svg";
            themeIcon.alt = "sun icon";
        }
        
        localStorage.setItem("theme", theme);
    }

    
    let theme = localStorage.getItem("theme") || "light";
    const isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
    if (isDarkMode) {
        
        setTheme('dark');

    } else {
        
        setTheme('light');
    }
    setTheme(theme);

    
    document.getElementById("theme-toggle").addEventListener("click", function() {
        if (theme === "light") {
            theme = "dark";
        } else {
            theme = "light";
        }
        setTheme(theme);
    });



</script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css" integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js" integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>

    
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>
</header><main>
<div class="single-container">
    <div class="archive">
        <h1 class="title is-1">Understanding the Crystal Ball Function</h1>
        <div class="title subtitle heading is-6">
            <div class="author-info columns is-vcentered">
                <div class="column">
                    <div class="columns is-vcentered is-mobile">
                        
                        <div class="column">
                            <p>John Burns</p>
                            <p><time>April 5, 2024</time>
                            </p>
                        </div>
                    </div>
                </div>
                <div class="small-categories-container">
                    
                </div>
            </div>
        </div>
        <div class="content article-content">
            <div class="toc-container">
                
    <div class="post-toc">
        
            <aside>
                <button id="tocButton" ><h4 id="contents" style="margin-left: 1vw;color:rgb(96, 134, 180);margin-bottom: 0;">CONTENTS</h4></button>
                <div id="hide"><nav id="TableOfContents">
  <ul>
    <li><a href="#introduction-to-the-crystal-ball-problem-with-arrays">Introduction to the Crystal Ball Problem with Arrays</a></li>
    <li><a href="#why-square-root-of-n">Why Square Root of ( n )?</a>
      <ul>
        <li><a href="#optimization-balance">Optimization Balance</a></li>
        <li><a href="#trade-off-between-jump-and-search">Trade-off Between Jump and Search</a></li>
        <li><a href="#theoretical-justification">Theoretical Justification</a></li>
      </ul>
    </li>
    <li><a href="#alternative-roots">Alternative Roots</a></li>
    <li><a href="#mathematical-justification">Mathematical Justification</a>
      <ul>
        <li><a href="#setting-up-the-problem">Setting Up the Problem</a></li>
        <li><a href="#total-search-steps">Total Search Steps</a></li>
        <li><a href="#finding-the-optimal-m">Finding the Optimal ( m )</a></li>
        <li><a href="#example-with-n-100">Example with ( n = 100 )</a></li>
        <li><a href="#explanation">Explanation</a></li>
        <li><a href="#conclusion">Conclusion</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </aside>
        
    </div><script>
    
        let button = document.getElementById('tocButton');
        let hide = document.getElementById("hide");
        let contents=document.getElementById("contents");
        button.addEventListener("click", function() {
        if (hide.style.display!='block') {
            hide.style.display='block'
        } else {
            hide.style.display='none'
            contents.style.color='rgb(96, 134, 180)'
        }
        });
    




</script>
            </div>
            <p>Date: <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-04-07 Sun&gt;</span></span></p>
<p>Subject: Understanding the Crystal Ball Function</p>
<p>Version: 1.0</p>
<!--start-summary-->
<p>Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.</p>
<!--nomore-->
<h2 id="introduction-to-the-crystal-ball-problem-with-arrays">Introduction to the Crystal Ball Problem with Arrays</h2>
<p>The <em>Crystal Ball Problem</em> in the context of arrays is a metaphorical representation of the challenge of predicting future elements or trends based on a current sequence of data. Imagine you have an array of numbers representing data points over time. The task is to predict the next set of values the array will hold using only the information currently available.</p>
<p>This problem encapsulates many real-world scenarios—from stock market predictions to weather forecasting—where accurately foreseeing future data points can lead to significant advantages. In computational terms, it often relates to the development of algorithms that efficiently analyze patterns within an array and extrapolate them to predict future outcomes.</p>
<p>Given an array ( A ) of length ( n ), with elements $$ A[1], A[2], \dots, A[n] $$, the challenge is to predict $$ A[n+1], A[n+2], \dots $$, assuming there are underlying patterns or rules governing the progression of the array&rsquo;s elements. The &ldquo;crystal ball&rdquo; here symbolizes the hypothetical ability to see into the future of the array&rsquo;s values.</p>
<p>The complexity of the Crystal Ball Problem can vary widely depending on the nature of the data and its inherent patterns. It might involve simple linear extrapolation, complex machine learning models, or even chaotic systems where accurate predictions are inherently difficult. The key lies in identifying and leveraging the mathematical or statistical relationships within the array to make informed predictions.</p>
<h2 id="why-square-root-of-n">Why Square Root of ( n )?</h2>
<h3 id="optimization-balance">Optimization Balance</h3>
<p>The choice of ( m ) (the block size) as the square root of ( n ) comes from optimizing the sum of the number of steps taken to jump to the block containing the target element and the steps taken to perform a linear search within the block. Mathematically, when you differentiate the total steps function with respect to ( m ) and set it to zero to find the minimum, you end up with ( m ) being proportional to $$ \sqrt{n} $$.</p>
<h3 id="trade-off-between-jump-and-search">Trade-off Between Jump and Search</h3>
<p>If the jump size is too large (e.g., using the cube root of ( n )), you minimize the number of jumps but potentially increase the length of the linear search within a block, leading to inefficiency. Conversely, smaller jumps (e.g., smaller than $$ \sqrt{n} $$ ) reduce the linear search phase but increase the number of jumps, also leading to inefficiency.</p>
<h3 id="theoretical-justification">Theoretical Justification</h3>
<p>From a theoretical standpoint, using the square root of ( n ) ensures that the maximum number of jumps (to find the right block) and the maximum number of linear searches within a block are balanced, thus optimizing the search time.</p>
<h2 id="alternative-roots">Alternative Roots</h2>
<p>Using a cube root or another root of ( n ) would skew the balance between the number of jumps and the linear search phase, potentially increasing the total search time. The square root of ( n ) optimally balances the algorithm, leading to a time complexity of
$$
O(\sqrt{n}),
$$
which is better than linear search’s $$ O(n) $$ but not as efficient as binary search’s $$ O(\log n) $$ for sorted arrays.</p>
<p>This explanation assumes a uniform distribution of search keys and does not take into account specific characteristics of the data, which might slightly affect the optimal block size in practice. However, for general purposes, the square root of ( n ) is a mathematically justified and practically effective choice.</p>
<h2 id="mathematical-justification">Mathematical Justification</h2>
<h3 id="setting-up-the-problem">Setting Up the Problem</h3>
<p>Jump Search involves jumping through an ordered list in increments of ( m ) (the jump size) and then performing a linear search within a block of size ( m ) once you&rsquo;ve jumped past the target element. The objective is to minimize the total search time, which is a function of ( m ).</p>
<ul>
<li><strong>Maximum number of jumps:</strong> $$ \frac{n}{m} $$</li>
<li><strong>Maximum number of steps in a linear search within a block:</strong> ( m - 1 ) (since after jumping, we might need to check up to ( m ) elements)</li>
</ul>
<h3 id="total-search-steps">Total Search Steps</h3>
<p>The total number of steps in the worst-case scenario can be approximated as the sum of the jumps and the linear search steps. We add 1 to the jump term to account for the final block where the linear search is performed:
$$
T(m) = \frac{n}{m} + (m - 1) + 1.
$$
Simplifying, we obtain:
$$
T(m) = \frac{n}{m} + m.
$$</p>
<h3 id="finding-the-optimal-m">Finding the Optimal ( m )</h3>
<p>To minimize ( T(m) ), we take the derivative of ( T(m) ) with respect to ( m ) and set it to zero:
$$
\frac{d}{dm}T(m) = -\frac{n}{m^2} + 1 = 0.
$$
Solving for ( m ):
$$
m^2 = n,
$$
which implies
$$
m = \sqrt{n}.
$$</p>
<h3 id="example-with-n-100">Example with ( n = 100 )</h3>
<p>Substituting ( n = 100 ):
$$
m = \sqrt{100} = 10.
$$</p>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Jump Size:</strong> The optimal jump size is 10 for an array of 100 elements. This means we jump every 10 elements (i.e., 0, 10, 20, …, 90), ensuring that we make at most 10 jumps.</li>
<li><strong>Linear Search:</strong> Once we&rsquo;ve jumped past the target element, we perform a linear search in a block of up to 10 elements, which, in the worst case, requires checking 9 additional elements.</li>
</ul>
<p>This method strikes a balance between the number of jumps and the size of the linear search, minimizing the total steps required in the worst case.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The choice of the square root of ( n ) optimizes the Jump Search by equally balancing the potential number of jumps with the maximum size of the linear search. For an array of 100 elements, this theoretical justification shows why jumping in steps of 10 is optimal. This balance ensures that the algorithm achieves its best possible efficiency, with a time complexity of
$$
O(\sqrt{n}),
$$
where ( n ) is the length of the array.</p>

        </div>
    </div>
    <a href="#" id="scrollToTopButton">
        <svg t="1686753152588" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"
            p-id="3988" width="48" height="48">
            <path
                d="M518.5 360.3c-3.2-4.4-9.7-4.4-12.9 0l-178 246c-3.8 5.3 0 12.7 6.5 12.7H381c10.2 0 19.9-4.9 25.9-13.2L512 460.4l105.2 145.4c6 8.3 15.6 13.2 25.9 13.2H690c6.5 0 10.3-7.4 6.5-12.7l-178-246z"
                p-id="3989" fill="#363636"></path>
            <path
                d="M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64z m0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z"
                p-id="3990" fill="#363636"></path>
        </svg>
    </a><hr style="border-top: 1px solid #EEEEEE;">
<div id="comment"></div>
<script>
    const getStoredTheme = () => localStorage.getItem("theme") === "dark" ? "dark" : "light";

    const setGiscusTheme = () => {
        const sendMessage = (message) => {
            const iframe = document.querySelector('iframe.giscus-frame');
            if (iframe) {
                iframe.contentWindow.postMessage({giscus: message}, 'https://giscus.app');
            }
        }
        sendMessage({setConfig: {theme: getStoredTheme()}})
    }

    document.addEventListener("DOMContentLoaded", () => {
        const giscusAttributes = {
            "src": "https://giscus.app/client.js",
            "data-repo": "bufo333\/johnburns.io_public",
            "data-repo-id": "R_kgDOHYBJIg",
            "data-category": "Announcements",
            "data-category-id": "DIC_kwDOHYBJIs4Cokmt",
            "data-mapping": "og:title",
            "data-reactions-enabled": "1",
            "data-emit-metadata": "0",
            "data-input-position": "bottom",
            "data-theme": getStoredTheme(),
            "data-lang": "en",
            "data-loading": "lazy",
            "crossorigin": "anonymous",
        };

        
        const giscusScript = document.createElement("script");
        Object.entries(giscusAttributes).forEach(
            ([key, value]) => giscusScript.setAttribute(key, value));
        document.getElementById("comment").appendChild(giscusScript);

        
        const themeToggle = document.querySelector(".theme-toggle");
        if (themeToggle) {
            themeToggle.addEventListener("click", setGiscusTheme);
        }
    });

</script>


<div class="pp-container">
        <section class="pre-and-post">
            <div class="has-text-left">
                
                <p>Previous post</p>
                <a href="https://johnburns.io/post/store-dotfile-with-git/">Store dotfile with git</a>
                
            </div>
            <div class="has-text-right">
                
                <p>Next post</p>
                <a href="https://johnburns.io/post/orbital-mechanics/">Mathematics &amp; Physics for understanding Orbital Mechanics</a>
                
            </div>
        </section>
    </div>

</div>

        </main><footer class="footer">
    <div class="content has-text-centered">
    <span>&copy; 2025 <a href="https://johnburns.io/">The Colour of My Thoughts</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" target="_blank">Hugo</a> &
    </span>
    </div>
  </footer></body>
</html>

