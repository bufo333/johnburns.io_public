<!DOCTYPE html>
<html lang=""><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <title>Understanding the crystal Ball Function</title>
    <meta name="description" content="The desk of my mind.">
    <meta name="author" content='John Burns'>

    <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" integrity="sha384-TX8t27EcRE3e/ihU7zmQxVncDAy5uIKz4rEkgIXeMed4M0jlfIDPvg6uqKI2xXr2" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" integrity="sha512-iBBXm8fW90+nuLcSKlbmrPcLa0OT92xO1BIsZ+ywDWZCvqsWgccV3gFoRBv0z+8dLJgyAHIhR35VZc2oM/gI1w==" crossorigin="anonymous">

    
    <link rel="stylesheet" href="/sass/researcher.min.css">

    
        <link rel="icon" type="image/ico" href="https://johnburns.io/favicon.ico">
    

    
        
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LQNL2E5MEL"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-LQNL2E5MEL', { 'anonymize_ip': false });
}
</script>

    
</head>

    <body><div class="container mt-5">
    <nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0">
        <a class="navbar-brand mx-0 mr-sm-auto" href="https://johnburns.io/" title="The Colour of My Thoughts">
          
          The Colour of My Thoughts
        </a>
        <div class="navbar-nav flex-row flex-wrap justify-content-center">
            
                
                
                    <a class="nav-item nav-link" href="/about/" title="About">
                        About
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/resume.pdf" title="Resume">
                        <svg width="1em" height="1em" viewBox="0 0 16 16" class="bi bi-file-earmark-person-fill" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M2 2a2 2 0 0 1 2-2h5.293A1 1 0 0 1 10 .293L13.707 4a1 1 0 0 1 .293.707V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2zm7.5 1.5v-2l3 3h-2a1 1 0 0 1-1-1zM11 8a3 3 0 1 1-6 0 3 3 0 0 1 6 0zm2 5.755S12 12 8 12s-5 1.755-5 1.755V14a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-.245z"/></svg> Resume
                    </a>
                    
                        <span class="nav-item navbar-text mx-1">/</span>
                    
                
                    <a class="nav-item nav-link" href="/contact/" title="Contact">
                        Contact
                    </a>
                    
                
            
        </div>
    </nav>
</div>
<hr>
<div id="content">
<div class="container">
    <p>Date: <span class="timestamp-wrapper"><span class="timestamp">&lt;2024-04-07 Sun&gt;</span></span></p>
<p>Subject: Understanding the crystal Ball Function</p>
<p>Version: 1.0</p>
<!--start-summary-->
<p>Exploring the intricacies of the Crystal Ball Problem as it applies to arrays, this piece delves into the challenge of predicting future elements based on current sequences. It underscores the significance of pattern recognition and algorithmic forecasting in computational analysis and real-world applications.</p>
<!--nomore-->
<h2 id="introduction-to-the-crystal-ball-problem-with-arrays">Introduction to the Crystal Ball Problem with Arrays</h2>
<p>The &ldquo;Crystal Ball Problem&rdquo; in the context of arrays is a metaphorical representation of the challenge of predicting future elements or trends based on a current sequence of data. Imagine you have an array of numbers representing data points over time. The task is to predict the next set of values the array will hold, using only the information currently available within it.</p>
<p>This problem encapsulates the essence of many real-world scenarios, from stock market predictions to weather forecasting, where the ability to accurately foresee future data points can lead to significant advantages. In computational terms, it often relates to the development of algorithms that can efficiently analyze patterns within an array and extrapolate them to predict future outcomes.</p>
<p>Given an array \(A\) of length \(n\), with elements \(A[1], A[2], &hellip;, A[n]\), the challenge is to predict \(A[n+1], A[n+2], &hellip;\), assuming there are underlying patterns or rules that govern the progression of the array&rsquo;s elements. The &ldquo;crystal ball&rdquo; here symbolizes the hypothetical ability to see into the future of the array&rsquo;s values.</p>
<p>The complexity of the &ldquo;Crystal Ball Problem&rdquo; can vary widely depending on the nature of the array&rsquo;s data and the patterns it follows. It might involve simple linear extrapolation, complex machine learning models, or even chaotic systems where accurate predictions are inherently difficult. The key lies in identifying and leveraging the mathematical or statistical relationships within the array to make informed predictions.</p>
<h2 id="why-square-root-of-n">Why Square Root of n?</h2>
<h3 id="optimization-balance">Optimization Balance</h3>
<p>The choice of m (the block size) as the square root of n comes from optimizing the sum of the number of steps taken to jump to the block containing the target element and the steps taken to perform a linear search within the block. Mathematically, when you differentiate the total steps function with respect to m and set it to zero to find the minimum, you end up with m being proportional to the square root of n.</p>
<h3 id="trade-off-between-jump-and-search">Trade-Off Between Jump and Search</h3>
<p>If the jump size is too large (e.g., using the cube root of n), you minimize the number of jumps but potentially increase the length of the linear search within a block, leading to inefficiency. Conversely, smaller jumps (e.g., smaller than the square root of n) reduce the linear search phase but increase the number of jumps, also leading to inefficiency.</p>
<h3 id="theoretical-justification">Theoretical Justification</h3>
<p>From a theoretical standpoint, using the square root of n ensures that the maximum number of jumps (to find the right block) and the maximum number of linear searches within a block are the same, thus optimizing the search time.</p>
<h2 id="alternative-roots">Alternative Roots</h2>
<p>Using a cube root or another root of n would skew the balance between the number of jumps and the linear search phase, potentially increasing the total search time. The square root of n optimally balances the algorithm, leading to a time complexity of \(O(\sqrt{n})\), which is better than linear search&rsquo;s \(O(n)\) but not as efficient as binary search&rsquo;s \(O(\log n)\) for sorted arrays.</p>
<p>This explanation assumes a uniform distribution of search keys and does not take into account specific characteristics of the data, which might slightly affect the optimal block size in practice. However, for general purposes, the square root of n is a mathematically justified and practically effective choice.</p>
<h2 id="mathematical-justification">Mathematical Justification</h2>
<h3 id="setting-up-the-problem">Setting Up the Problem</h3>
<p>Jump Search involves jumping through an ordered list in increments of m (the jump size) and then performing a linear search within a block of size m once we&rsquo;ve jumped past the target element. The objective is to minimize the total search time, which is a function of m.</p>
<ul>
<li>The maximum number of jumps: \(n/m\)</li>
<li>The maximum number of steps in a linear search within a block: \(m - 1\) (since after jumping, we might need to check up to m elements).</li>
</ul>
<h3 id="total-search-steps">Total Search Steps</h3>
<p>The total number of steps in the worst-case scenario can be approximated as the sum of the jumps and the linear search steps. We add 1 to the jump term to account for the final block where the linear search is performed:</p>
<p>\[T(m) = n/m + (m - 1) + 1\]</p>
<p>Simplifying, we get:</p>
<p>\[T(m) = n/m + m\]</p>
<h3 id="finding-the-optimal-m">Finding the Optimal m</h3>
<p>To minimize \(T(m)\), we take the derivative of \(T(m)\) with respect to m and set it to zero:</p>
<p>\[\frac{d}{dm}T(m) = -\frac{n}{m^2} + 1 = 0\]</p>
<p>Solving for m, we find:</p>
<p>\[m^2 = n\]</p>
<p>\[m = \sqrt{n}\]</p>
<h3 id="example-with-n-100">Example with n = 100</h3>
<p>Substituting \(n = 100\):</p>
<p>\[m = \sqrt{100} = 10\]</p>
<h3 id="explanation">Explanation</h3>
<ul>
<li>Jump Size: The optimal jump size is 10 for an array of 100 elements. This means we jump every 10 elements (0, 10, 20, &hellip; 90), ensuring that we make at most 10 jumps.</li>
<li>Linear Search: Once we&rsquo;ve jumped past the target element, we perform a linear search in a block of up to 10 elements, which, in the worst case, requires us to check 9 additional elements.</li>
</ul>
<p>This method strikes a balance between the number of jumps and the size of the linear search, minimizing the total steps required in the worst case.</p>
<h3 id="conclusion">Conclusion</h3>
<p>The square root choice optimizes the Jump Search because it equally balances the potential number of jumps and the maximum size of the linear search. For an array of 100 elements, this theoretical justification shows why jumping in steps of 10 is optimal. This balance ensures the algorithm achieves its best possible efficiency, with a time complexity of \(O(\sqrt{n})\), where n is the length of the array.</p>

</div>

        </div><div id="footer" class="mb-5">
    <hr>
    
    <div class="container text-center">
        
            <a href="https://twitter.com/" class="fab fa-twitter fa-1x" title="Twitter"></a>
        
            <a href="mailto:john@techinvasion.net" class="fas fa-envelope fa-1x" title="E-mail"></a>
        
    </div>
    
    
        <div class="container text-center">
            <a href="https://github.com/bufo333/" title="By John Burns"><small>By John Burns</small></a>
        </div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\[", right: "\\]", display: true},
                {left: "$", right: "$", display: false},
                {left: "\\(", right: "\\)", display: false}
            ]
        });
    });
</script>
</div>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1329465157209102"
    crossorigin="anonymous"></script>
    </body>
</html>
